## links
* 论文链接：[Testing Graph Database Systems via Graph-Aware Metamorphic Relations | Proceedings of the VLDB Endowment](https://dl.acm.org/doi/10.14778/3636218.3636236)
* 论文分析：[Testing Graph Database Systems via Graph-Aware Metamorphic Relations论文笔记_配偶节点-CSDN博客](https://blog.csdn.net/qq_38135755/article/details/144200632)


## ABSTRACT
Graph database systems (GDBs) have supported many important real-world applications such as social networks, logistics, and path planning. Meanwhile, logic bugs are also prevalent in GDBs, leading to incorrect results and severe consequences. However, the logic bugs largely cannot be revealed by prior solutions which are unaware of the graph native structures of the graph data. In this paper, we propose Gamera (Graph-aware metamorphic relations), a novel metamorphic testing approach to uncover unknown logic bugs in GDBs. We design three classes of novel graph-aware Metamorphic Relations (MRs) based on the graph native structures. Gamera would generate a set of queries according to the graph-aware MRs to test diverse and complex GDB operations, and check whether the GDB query results conform to the chosen MRs. 

We thoroughly evaluated the effectiveness of Gamera on seven widely-used GDBs such as Neo4j and OrientDB. Gamera was highly effective in detecting logic bugs in GDBs. In total, it detected 39 logic bugs, of which 15 bugs have been confirmed, and three bugs have been fixed. Our experiments also demonstrated that Gamera significantly outperformed prior solutions including Grand, GDsmith and GDBMeter. Gamera has been well-recognized by GDB developers and we open-source our prototype implementation to contribute to the community.

图数据库系统（GDBs）已经支持了许多重要的现实世界应用，如社交网络、物流和路径规划。然而，逻辑错误在GDBs中也普遍存在，导致错误的结果和严重的后果。然而，这些逻辑错误在很大程度上无法通过之前的解决方案揭示，因为这些解决方案不了解图数据的原生结构。在本文中，我们提出了Gamera（图感知的蜕变关系，Graph-aware metamorphic relations），一种新颖的蜕变测试方法，用于发现GDBs中的未知逻辑错误。我们基于图原生结构设计了三类新颖的图感知蜕变关系（MRs）。Gamera将根据图感知的MRs生成一组查询，以测试多样且复杂的GDB操作，并检查GDB查询结果是否符合所选的MRs。

我们在Neo4j和OrientDB等七个广泛使用的GDBs上全面评估了Gamera的有效性。Gamera在检测GDBs中的逻辑错误方面非常有效。总共检测到39个逻辑错误，其中15个错误已得到确认，3个错误已修复。我们的实验还表明，Gamera显著优于包括Grand、GDsmith和GDBMeter在内的先前解决方案。Gamera已得到GDB开发者的广泛认可，并且我们开源了我们的原型实现，以贡献给社区。

## INTRODUCTION

图形数据库系统（Graph database systems，GDBs）
* 用于处理包含节点和边的图数据
* 实际应用：在诸如社交网络[29]、物流和路径规划等众多重要的实际应用被广泛使用，以实现图数据的高效存储和查询。

GDBs中的逻辑错误
* 定义：通常是指在图形数据的表示、存储或查询方式中出现的错误或缺陷，导致错误的结果，例如在查询结果中遗漏预期的节点。
* 威胁：逻辑错误可能导致不正确的结果和严重的后果。例如，社交网络 GDB 中的逻辑错误可能会导致错误的好友推荐，从而引起用户不满。
* 例子：基于本文方法在RedisGraph（查询语言为**Cypher**）中发现的一个逻辑错误
	* 第1行的查询计算了ID为0的第一个节点和ID为1的第二个节点之间的路径数量。
	* 第3行的查询计算了ID为1的第二个节点和ID为2的第三个节点之间的路径数量。
	* 在第5行计算从ID为0的节点开始，经过ID为1的节点，最终到达ID为2的节点的路径数量，应该等于这两个查询结果的乘积，即零。然而，第5行的查询错误地返回了四，这表明其存在逻辑错误。
   ![[Pasted image 20250203155503.png]]

> [!NOTE] Cypher语法解释
1. **MATCH path=(a)-[*]-(b)**
- **MATCH**：用于匹配图数据库中的模式（Pattern）。
- **path=(a)-[*]-(b)**：
    - `(a)` 和 `(b)` 是两个节点，分别表示路径的起点和终点。
    - `[*]` 是一个可变长度的路径匹配符号，表示从 `a` 到 `b` 之间的任意长度的路径（包括直接连接和多跳连接）。
    - `-` 表示节点之间的边（关系）。
    - `path` 是一个变量，用于存储匹配到的路径。
* ***作用**：查找从节点 `a` 到节点 `b` 的所有可能路径，并将这些路径存储在变量 `path` 中。

2. **WHERE ID(a)=0 AND ID(b)=1**
- **WHERE**：用于过滤匹配的结果。
- **ID(a)=0**：指定节点 `a` 的 ID 为 0。
- **ID(b)=1**：指定节点 `b` 的 ID 为 1。
- **作用**：限制查询的范围，只查找从 ID 为 0 的节点到 ID 为 1 的节点之间的路径。
3. **RETURN COUNT(path)**
- **RETURN**：用于返回查询结果。
- **COUNT(path)**：计算匹配到的路径数量。
- **作用**：返回从节点 `a` 到节点 `b` 的所有路径的总数。

## BACKGROUND AND MOTIVATION
### Labeled Property Graph in GDBs
图形数据库系统通常使用标记属性图模型(Labeled property graph model [44])来表示其图形结构。
* 该模型包含一组节点(nodes)和与这些节点相关联的一组边(edges)。
* 每个节点或边都有一个附加的标签(labels)，用于将其划分到特定的组中。同时，一组键值对属性(key-value pair attributes)用于描述节点或边的特性并提供额外的元数据。

样例如下图所示：
![[Pasted image 20250203162912.png]]

* 该图由两个节点和一条边组成。
* 一个带有标签 **person** 的节点（v:1）具有属性 **name** 和 **age**，而另一个带有标签 **software** 的节点（v:2）具有属性 **name** 和 **lang**。一条带有标签 **created** 的有向边（e:1）具有属性 **since**，表示某人创建该软件的时间。
* graph native structures: 本文将图数据库（GDBs）中带标签的属性图的节点、边和路径定义为图原生结构。

```
例如，一个节点可以用<标签，属性集>的形式表示。如<person，«name，String»，«age，Integer»>代表一个具有 “person” 标签，包含 “name” 为字符串类型属性和 “age” 为整数类型属性的节点。同样，一条有向边可以表示为<标签，属性集，起始节点，结束节点>。
```
### Graph Query Languages

* 不同的图形数据库支持不同的图形查询语言。例如，Neo4j 开发了 Cypher，TinkerPop 开发了 Gremlin，TigerGraph 开发了 GSQL，ArangoDB 开发了 AQL 等。
* **大多数图形数据库使用 Cypher 和 Gremlin 进行图形数据管理。** 本文主要关注Cypher-based 和Gremlin-based GDBs。

**Cypher(ˈsaɪfə(r))**
* 一种声明式且类似于 SQL 的查询语言（declarative and SQL-like query language），允许在标记属性图中匹配节点和边。
* 使用 ASCII-art 语法，例如用圆括号表示节点，用箭头表示边。通过使用诸如 MATCH、WHERE 和 RETURN 等操作符，可以描述子图、添加约束以及指定结果的输出方式。
* 示例：`MATCH (p:person)-[:created]->(:software) WHERE p.age > 25 RETURN p.name`。该查询返回年龄超过 25 岁且创建了软件的人员的姓名。在这个查询中，`MATCH` 是一个操作符，通常用于描述子图以查找节点、边或路径；`WHERE` 用于为子图添加额外的约束条件并过滤掉不需要的子图；`RETURN` 指定了结果的输出方式。

**Gremlin**
* 一种函数式语言（a functional language），遍历操作符被链接在一起形成类似路径的表达式。一个 Gremlin 查询由一系列 Gremlin 遍历原语组成，最终计算出最终的输出结果。
* 示例：`g.V().where(values('name').is(eq('Alice'))).outE('created').inV().hasLabel('software').values('lang')`。该查询首先使用 `g.V()` 获取所有节点，然后使用 `where()` 和 `eq()` 过滤出名字为 Alice 的节点。通过使用 `outE('created').inV()` 遍历边，可以访问 Alice 创建的软件。最后，通过 `hasLabel()` 和 `values()` 返回软件的语言。在这个示例中，`where()` API 中存在一个嵌套查询，其中 `is()` 用于评估属性值是否与谓词匹配。


### Existing Approaches and Limitations

表1中总结了现有的图数据库（GDB）基准测试解决方案。

  ![[Pasted image 20250203175751.png]]
  
**差异测试（Differential Testing, DT）**：如 **GDsmith [32]** 和 **Grand [47]**。
1. 定义：将相同查询输入到多个 GDBs 中，旨在发现它们之间的不一致结果。
2. 代表方法：
 * GDsmith 和 Grand 首次分别使用差异测试来检测基于Cypher和基于Gremlin的GDB漏洞。
* **GDsmith [北大]**：
	* GDsmith 是首个用于测试图数据库引擎的黑盒方法，它解决了随机测试面临的语义有效性、非空结果和行为多样性挑战。GDsmith 采用了**骨架生成和补全技术**确保随机生成的 Cypher 查询满足语义要求，利用**三种结构变异策略**增加返回非空结果的 Cypher 查询的概率，并**根据属性键的先前频率动态选择属性键以提高生成的 Cypher 查询的行为多样性**。我们的评估结果表明，GDsmith 在自动查询生成方面有效且高效，大大优于基线方法。GDsmith 成功地在三个流行的开源图数据库引擎的发布版本上检测到 27 个先前未知的漏洞。
	* 首先，GDsmith 随机生成数据库状态，并初始化配置变量。在每次迭代中，GDsmith 会先随机生成属性图模式，这一模式定义了标签、关系类型和属性。
	* 接着，GDsmith 通过随机生成或变异的方式产生语义有效的 Cypher 查询。为了解决语义有效性挑战，GDsmith 采用了基于骨架的完成技术。具体来说，GDsmith 先随机生成一个 Cypher 骨架，这个骨架是由带有未实例化部分（如模式和表达式）的子句序列组成，每个未实例化部分用 “□” 符号表示。例如，对于一个特定的 Cypher 查询，其对应的骨架可能是 “MATCH □ WHERE □ RETURN □”。随机生成 Cypher 查询分为两步，首先随机生成骨架，然后填充骨架中的未实例化部分。在填充过程中，GDsmith 会计算并维护每个子句的上下文。上下文包括局部环境和事实两方面信息。局部环境是指下一个子句中可用的变量集合，对于不同类型的子句，局部环境的确定方式不同。例如，对于 MATCH 子句，局部环境包括前一个子句的局部环境中的变量以及节点模式和关系模式中新定义的实体变量。事实则是从变量定义中收集的信息，包含每个变量的数据类型以及节点的标签约束和关系的类型约束等。基于丰富的语义信息，GDsmith 能够使生成的未实例化部分满足变量作用域正确性、操作数类型安全和属性键安全三个语义要求。
	* 然后，GDsmith 在每个引擎实例上执行生成的查询。
	* 最后，GDsmith 保留返回非空结果的 Cypher 查询，并利用属性键频率的反馈生成新的具有高行为多样性的 Cypher 查询。如果一个查询返回非空结果，GDsmith 会将其保留到查询池中，这些保留的查询将用于在后续阶段通过结构变异策略生成新的查询，从而增加新变异查询返回非空结果的概率。同时，GDsmith 会根据属性键的先前频率动态选择属性键来完成新的骨架，以提高生成的 Cypher 查询的行为多样性。其目的是覆盖不同的属性值，从而提高随机生成查询的行为多样性。
* **Grand [中科院技术研究所]**：
	* Grand，一种用于自动发现采用Gremlin检索图数据的图数据库系统中逻辑错误的随机差异测试方法，并在六种广泛使用的图数据库系统中发现了21个先前未知的逻辑错误。、
	* 过去方案: 与关系数据库系统不同，图数据库系统的逻辑错误难以自动检测，因为它们通常使用自己的查询语言，语法和查询模式与SQL完全不同。
	* 论文的Motivation: 本研究的动机在于解决图数据库系统中逻辑错误难以自动检测的问题，通过提出Grand方法，利用随机差异测试发现逻辑错误，并在六种广泛使用的图数据库系统中取得了显著成果。
	- 技术路线:为多个GDBs构建语义等价数据库；基于模型的查询生成方法来生成可能返回非空结果的有效Gremlin查询；使用数据映射方法统一不同GDBs的查询结果格式。
![[GrandOverview.png]]

* ***图数据库生成**：Grand首先随机生成图模式，定义顶点和边的类型、标签和属性（步骤1）。接着，根据生成的图模式随机生成详细的顶点和边（步骤2）。然后，生成的数据库将被写入目标GDBs（步骤3）。
* ***Gremlin查询生成**：使用基于模型的查询生成方法来生成语法正确且有效的Gremlin查询。具体来说，首先为Gremlin API构建一个遍历模型（步骤4），然后基于构建的遍历模型和生成的图数据库生成Gremlin查询（步骤5）。这样做可以高概率地返回非空的查询结果。
* ***GDBs的差异测试**：执行生成的Gremlin查询（步骤6），通过差异测试验证查询结果。具体而言，对于每个目标GDB，记录每个查询的结果，并借助映射信息将其转换为统一的查询结果（步骤7）。然后，Grand检查这些统一结果以识别是否存在差异（步骤8）。如果某些GDBs显示不同的输出，则发现潜在的错误。
* **获取不同GDBs中格式统一的查询结果**：利用数据映射方法，在不同GDBs中获取统一的查询结果。这使得该方法能够比较不同GDBs返回的不同格式的查询结果。


3. 局限性：**所有 GDBs 返回相同的结果并不一定意味着正确性。** 使用不一致性作为差异测试的测试预言（oracle）会带来两个问题：  
* 被测GDBs 可能存在相同逻辑错误：它无法检测所有被测试 GDBs 中都存在的错误，因为这些 GDBs 可能始终返回相同的不正确结果  
* 被测功能有限：只能测试被测 GDBs 之间重叠的通用功能，而无法测试特定 GDB 的独特功能


**蜕变测试（Metamorphic Testing, MT）**
1. 定义：精心设计蜕变关系（Metamorphic Relations，MRs），对输入进行变异，检查输出是否违反所规定的属性来检测错误。
2. 蜕变关系缓解了差异测试预言的问题，不需要存在多个类似的程序实现（例如，在 GDB 测试中不需要多个数据库系统）
3. 代表方法：
* SQLancer[18] 
	* 针对 关系数据库系统，SQLancer [18] 利用了三元逻辑划分（ternary logic partitioning, TLP）[42] 和非优化参考引擎构建（non-optimizing reference engine construction, NoREC）[41] 来形成 MRs 并检测逻辑错误。
	* NoREC ：比较给定优化查询与其非优化版本的执行结果，来检测与优化相关的漏洞。
	* TLP ：将查询划分为三个子查询，并通过比较三个子查询的组合结果与原始结果来检测逻辑漏洞。
* GDBMeter[34] 
	* GDBMeter 是唯一采用蜕变测试（Metamorphic Testing，MT）的图形数据库测试工具。它将关系数据库中使用的三元查询分区（ternary query partitioning，TLP ）[42] 的思想移植到 GDB 中。它将给定的查询拆分为三个派生子查询，其中谓词分别被评估为 `TRUE`、`FALSE` 和 `IS NULL`。然后，它验证派生结果集的并集与原始结果集之间的一致性。
	* 不同的数据库管理系统如 Oracle、MySQL、SQL Server 和 PostgreSQL 都有各自独特的查询分区方式，为实际应用提供了多种选择。
	* 通过查询分区方法对图数据库引擎进行测试，可以提高测试的效率和准确性。
4. 局限性：**现有的蜕变测试（MT）解决方案上述方法都是为使用SQL类或其他图查询语言的数据库系统设计的，并未关注 GDBs 中的图原生结构，因此未能提出一套图感知的MR，这限制了它们的有效性**。原因有以下两点：  
* 覆盖语法有限（局限一）：GDBs 的图查询语言包含了与图原生结构相关的丰富语法，而现有的 MT 方法仅覆盖了有限的语法。例如，常用的路径遍历（path traversal）语法和 `𝑢𝑛𝑖𝑜𝑛` 子句在之前的工作中并未得到支持。  **测试覆盖不足**：由于语法支持的局限性，现有方法无法充分测试 GDBs 中的所有基本操作。  
* 缺乏针对图形原生结构的有效测试预言（局限二）：不能充分识别与图形原生结构相关的逻辑错误。例如，GDBMeter 直接复用关系数据库系统中的三元查询分区方法，而没有分析图形数据库独特的图形原生结构，因此无法全面测试图形数据库。

> [!NOTE] 相关工作论文笔记
> * [GDsmith：Detecting Bugs in Graph Database Engines 论文笔记_detecting transactional bugs in database engines v-CSDN博客](https://blog.csdn.net/qq_38135755/article/details/144200584)
> * Grand: [Finding Bugs in Gremlin-Based Graph Database Systems via Randomized Differential Testing | LinLi's Blog](https://linli1724647576.github.io/2024/03/01/Finding-Bugs-in-Gremlin-Based-Graph-Database-Systems-via-Randomized-Differential-Testing/)
>   SQLancer: 
> * GDBMeter: [Testing Graph Database Engines via Query Partitioning 论文笔记-CSDN博客](https://blog.csdn.net/qq_38135755/article/details/144200617?spm=1001.2014.3001.5502)


### Motivation

5. 大多数先前的数据库 MT 工作都集中在关系数据库系统上 [18, 41, 42]。由于关系数据库系统和图数据库系统之间存在巨大差异（例如，查询语言、存储数据的结构等），这些方法大多无法直接应用于 GDB 领域。

逻辑错误的自动化检测：这些错误主要源于图数据库引擎的错误实现或优化[39]。**由于逻辑错误通常不会导致系统崩溃，自动检测这些错误本身具有挑战性。


为了解决这一问题，本文提出了 Gamera（Graph-aware metamorphic relations），这是一种新颖的蜕变测试方法，旨在揭示图形数据库系统中的未知逻辑错误。Gamera 基于图形的原生结构设计了三类新颖的图形感知蜕变关系（Metamorphic Relations，MRs），通过生成一组查询来测试各种复杂的 GDB 操作，并检查 GDB 查询结果是否符合所选的 MRs。

## OVERVIEW
### 解决现有方法的局限性

为了解决现有图数据库的蜕变测试方法的两大局限性，**本文提出了 Gamera，一种有效且自动化的蜕变测试解决方案**，用于检测图数据库系统中的逻辑错误。
* 针对局限一：支持更多图查询语法（例如路径遍历、`𝑢𝑛𝑖𝑜𝑛` 子句等），能够更好地测试图形数据库的基本操作，揭示相关逻辑错误。这些语法适用于两种主流的图查询语言——**Cypher** 和 **Gremlin**。
* 针对局限二：提出一组新的图感知蜕变关系（MRs）。这些新 MRs 能感知图原生结构和特性，从而定义有效的测试预言。这些 MRs 分为三类，可以全面测试 GDBs 的各种功能。基本 MR 用于测试图形数据库的基本功能，如节点和边的关系、路径的连通性等；复合 MR 通过生成更复杂的查询模式从基本 MR 构建而来，测试更复杂的图形数据库功能；动态 MR 考虑图形数据的动态更新，测试图形数据库对动态数据更新的支持。

全面的语言语法支持和新的图感知 MRs 使 Gamera 能够暴露与图原生结构相关的新类别逻辑错误，而这些错误是现有解决方案无法发现的。

### Gamera 的工作流程
![[Pasted image 20250203223118.png]]

6. 图模式生成（Graph Schema Generation，①）：定义节点和边的标签，以及它们的属性名称和对应类型。
7. 图数据生成（Graph Data Generation，②）：基于生成的图形模式随机创建图形数据，图数据通过一系列随机的基于图模式的图查询插入。
8. Gamera 参考新的图感知基础 MR③、复合 MR④和动态 MR⑤来测试图数据库（GDB）。在每个测试中，它基于图感知 MR 生成一组查询（例如，𝑄1、𝑄2、𝑄3）。
9. Gamera 使用相应的预言来标记并报告 bug。预言会检查这些查询产生的结果集 𝑅1、𝑅2、𝑅3 是否符合所选的 MR。如果 MR 存在一致性违规，则表示图数据库中存在逻辑 bug。

#### 图模式生成
通过强制执行图模式，GDBs 确保只有有效的查询才能在数据上执行，防止执行引用了不存在的节点、边或属性的查询，从而避免无意义的查询。
* 节点 𝑉 ： 表示为 <𝐿_𝑉 , P_𝑉 >，其中 𝐿_𝑉 描述节点的标签，P_𝑉 描述其对应的属性。
* 有向边𝐸 ：表示为 <𝐿_𝐸, P_𝐸, 𝑠𝑡𝑎𝑟𝑡𝑉 , 𝑒𝑛𝑑𝑉 >，其中 𝐿_𝐸 描述边的标签，P_𝐸 描述其属性，且 𝑠𝑡𝑎𝑟𝑡𝑉 , 𝑒𝑛𝑑𝑉 表示一个起始节点和一个结束节点。
𝐿_𝑉 , 𝐿_𝐸 是随机生成的字符串；P_𝑉 , P_𝐸 是由元素 <𝑝𝑟𝑜𝑝𝑒𝑟𝑡𝑦𝑁𝑎𝑚𝑒, 𝑇> 组成的集合，其中 𝑝𝑟𝑜𝑝𝑒𝑟𝑡𝑦𝑁𝑎𝑚𝑒 和 𝑇 分别表示属性名称和数据类型（例如，整数、浮点数、字符串、布尔值和点）。

例如，图 1 中的节点 v:1 可以表示为 <person, «name, String>, <age, Integer»>。

#### 图数据生成
Gamera 基于生成的图形模式随机创建图形数据，其中包括 𝑛 个节点和 𝑚 条边（𝑛 和 𝑚 是可配置的参数）。
* 首先创建 𝑛 个节点。
* 从 |𝑛 × 𝑛| 个可能的边中随机创建 𝑚 条边。
* 初始化节点和边：创建节点或边时，会为其分配标签和从可用属性集中选择的属性（name-value pairs）。
* 生成图形数据：自动向 GDB 提交一系列图查询（例如，创建和更新查询）来实现图数据生成，生成的图形数据具有随机性和多样性。

> [overflow 结合前面逻辑错误样例] 
> 我们进一步使用清单 1 中的示例来演示 Gamera 在 GDBs 中检测逻辑错误的工作流程。首先，Gamera 随机生成一个包含 100 个节点和 200 条边的图模式和图数据。节点和边的数量可以自定义。然后，它根据清单 1 中展示的 MR 生成三个测试查询。具体来说，𝑄1（第 1 行）、𝑄2（第 3 行）和 𝑄3（第 5 行）用于计算节点之间的路径数量。𝑄3 是相应的 oracle 语句，用于检查 𝑅3（第 6 行）是否与从 𝑅1（第 2 行）和 𝑅2（第 4 行）计算得出的结果一致。由于存在 MR 违规，Gamera 将其报告为一个错误。



## GRAPH-AWARE MRS

目标：测试图数据库（GDB）中最基本和常用的操作，并揭示其中的逻辑错误。
推导出一组新的图感知的蜕变关系（MRs，如表2所示）。

![[Pasted image 20250204093029.png]]

**elementary graph-aware MRs**
* 测试范围：用于测试图数据库的基本功能，支持对图基本类型（节点，边和路径）的操作。

**compound graph-aware MRs（复合的图感知MR）**
* 测试范围：用于测试和验证图数据库中更复杂的功能。
* 图原生结构之间的交互是多样且复杂的。例如，节点和边的不同分布揭示了图中的不同行为模式——即图中包含不同的集群或社区。节点可以涉及多种类型的有向边，并且可能包含循环。此外，图具有多种路径连接模式，如密集或稀疏图，以及规则或不规则图。检查连通性（即确认路径是否存在）涉及许多路径遍历算法[16]。基于图原生结构之间复杂的内在交互，我们相应地提出了复合MRs以确保其正确性。

**dynamic graph-aware MRs** 
* 测试范围：用于测试图数据库支持动态数据更新的功能。
* 图数据库中的图数据可以是动态的，它们可能因图查询而随时间变化。节点可能形成新的边，而现有的边可能断裂。

### 4. 1 Elementary MRs
* 定义了两类基本的图感知蜕变关系（MRs）： 根据查询中的图数据类型，基本MRs被分为节点和边级别的MRs，以及路径级别的MRs。
* 设计了全面的查询模式，以覆盖大多数基本的GDB操作
#### 4.1.1 Node & Edge Level MRs
**1 节点层面的MR（Node Level MR）—— 节点之间关系**
我们首先提出了几个用于测试节点之间关系的MR。
* spouse（配偶）relationships（v:1和v:2）：拥有相同子节点的节点，有指向相同子节点的出边。
	* MR：对于节点A，对于任意的 B 属于 𝑠𝑝𝑜𝑢𝑠𝑒𝑠 (𝑣_𝐴)，必有A 属于 𝑠𝑝𝑜𝑢𝑠𝑒𝑠 (𝑣_B)。
	* 解释：首先，我们获取节点𝐴的所有配偶节点集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠 (𝑣𝐴)；对于集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠 (𝑣𝐴)中的任意节点𝐵，我们获取其配偶节点集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠 (𝑣𝐵)。然后，节点𝐴必须是集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠 (𝑣𝐵)的成员，这一点可以作为oracle来验证并报告错误。
* ancestor（祖先）和 descendant（后代） relationships（v:1是v:3的祖先，v:5是v:2的后代）：节点𝐴通过一系列有向边到达节点𝐵，则节点𝐵是节点𝐴的后代，节点𝐴是节点𝐵的祖先。
	* MR：如果节点𝐴在集合𝑎𝑛𝑐𝑒𝑠𝑡𝑜𝑟𝑠 (𝑣_𝐵)中，则节点𝐵必须在节点集合𝑑𝑒𝑠𝑐𝑒𝑛𝑑𝑎𝑛𝑡𝑠 (𝑣_𝐴)中，反之亦然。

![[Pasted image 20250204102146.png]]

**2 K跳邻居MR（K-hop Neighbour MR）—— 节点和边之间关系**
* 定义：从节点𝐴出发，通过K条有向边（无论是入边还是出边）可以到达的节点集合（节点v:5是节点v:2的出方向2跳邻居节点）。
* 形式化：𝑛𝑒𝑖𝑔ℎ𝑏𝑜𝑢𝑟𝑠 (𝑣_𝐴, 𝑘) = {𝑣 ∈ 𝑉 | 𝑑𝑖𝑠𝑡𝑎𝑛𝑐𝑒 (𝑣_𝐴, 𝑣) = 𝑘 }
* MR：如果节点𝐵属于出方向（outgoing） 𝑛𝑒𝑖𝑔ℎ𝑏𝑜𝑢𝑟𝑠 (𝑣𝐴, 𝑘)中，则𝐴也必须属于入方向（incoming）𝑛𝑒𝑖𝑔ℎ𝑏𝑜𝑢𝑟𝑠 (𝑣𝐵, 𝑘)中。
* 解释：如果节点𝐵在节点𝐴的出方向K跳邻居集合𝑛𝑒𝑖𝑔ℎ𝑏𝑜𝑢𝑟𝑠 (𝑣𝐴, 𝑘)中，则预言机（oracle）可以检查节点𝐴也必须在节点𝐵的入方向K跳邻居集合𝑛𝑒𝑖𝑔ℎ𝑏𝑜𝑢𝑟𝑠 (𝑣𝐵, 𝑘)中。如果节点𝐴被排除在该集合之外，则发现了一个逻辑错误。

**3 边属性MR（Edge Property MR）—— 边之间关系**。
* 定义：将具有相同属性名的边定义为同质边，而将具有不同属性名的边定义为异质边。（在图3(a)中，红色的边e:1和e:2表示具有相同属性的边，而不同颜色的边（例如e:1、e:3和e:4）表示具有不同属性的边。）
* MR：由选定属性边连接到节点𝐴的所有配偶节点集合为𝑠𝑝𝑜𝑢𝑠𝑒𝑠′ (𝑣𝐴)。对于集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠′ (𝑣𝐴)中的任意节点𝐵，我们获取其由相同选定属性边连接的配偶节点集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠′ (𝑣𝐵)。然后，节点𝐴应该位于集合𝑠𝑝𝑜𝑢𝑠𝑒𝑠′ (𝑣𝐵)中。
* 解说：特别是，我们在节点层面元规则和K跳邻居元规则的基础上设计了边属性元规则，以增加查询的复杂性。通过考虑边属性，我们可以在图遍历过程中进一步选择具有相同属性的同质边或具有选定属性集的异质边，从而增加节点层面元规则和K跳邻居元规则的复杂性。

#### 4.1.2 Path Level MRs
* 图数据库（GDBs）实现了多种路径查找算法 [16, 22]，用于检索图中的路径。
* 路径级别蜕变关系主要实现图数据库中路径相关操作的正确性测试。

**1 连通性MR(connectivity MR)**
* 定义：图中是否存在至少一条路径连接这两个节点。
* MR：节点 A 与节点 B 相连，节点 B 与节点 C 相连，则存在从节点 A 到节点 C 的路径。
* 解释：根据这一连通性MR开发了一组连通性查询。具体来说，如果节点𝐴连接到节点𝐵，且节点𝐵连接到节点𝐶，那么预言机（oracle）可以检查是否存在至少一条从节点𝐴到节点𝐶的路径。

**2 路径数量计算MR(path number calculation MR)**
* 定义：计算任意两个节点之间的路径数量是图数据库的常用功能。构造直接和间接计算两个节点之间路径数量的查询。
* MR：从𝐴到𝐵的路径数量为𝑥，从𝐵到𝐶(不包含𝐴)的路径数量为𝑦，从𝐴经过𝐵到𝐶的路径数量为𝑧。应有𝑧=𝑥 * 𝑦。
* 解释：我们的评估结果表明，这种元规则（MR）有助于在复杂和大规模的图数据库（如RedisGraph [17]和OrientDB [15]）中发现多个错误。

**3 最短路径MR(shortest path MR)**
* 定义：搜索两个节点之间的最短路径也是图数据库的一个关键操作。移除原始最短路径上的一个关键节点，两个节点之间的最短路径不会变得更短。
* MR：p为节点 A 到节点 B 的最短路径；delete P上的一个中间关键节点C，p’为新最短路径，则必有length (p) ≤ length (p')
* 解释：首先查询从节点 A 到节点 B 的最短路径 P，并选择路径上的一个中间关键节点 C。然后从图中排除节点 C，查询从 A 到 B 的新最短路径 p'。预言机通过评估 length (p) ≤ length (p') 来检查最短路径是否在排除关键节点后不会变短。

### 4.2 Compound MRs

* 基础MR只能测试单独的图操作功能，例如查询少量特定节点、边或路径。许多逻辑错误只有在图数据库执行更复杂操作时才会显现。
* 本文提出了复合蜕变关系。通过从基本蜕变关系中的简单查询模式生成更复杂的图形查询模式，从而构建复合蜕变关系。
#### 4.2.1 Query Pattern Generation(查询模式生成) 

* 图查询模式定义：用于查询原始图数据（如节点、边或路径）的图匹配模式。
* 两种方法生成基本图查询模式
	* 根据基础MRs直接生成：这类查询模式对原始图数据执行基本图数据操作。（例如，这些基本查询模式可以查询某个节点的邻居节点或配偶节点，或者查询任意两个节点之间的（最短）路径）
	* 随机构建匹配标准：随机指定一些关于节点或边属性的匹配标准，或者对某些路径添加约束（例如包含或排除某些特定的中转节点）。通过组合多个随机匹配标准，生成的查询模式将在图形数据库中调用相当复杂的操作。

#### 4.2.2 Query Pattern Transformation

* 以基本图查询模式作为构建块，通过两种查询模式操作技术生成等效但更复杂的查询模式，以触发GDBs中更多的代码。
![[Pasted image 20250204161646.png]]

**1 Pattern Fusion(模式融合技术)**
* 定义
	* 通过逻辑操作将两个或多个图查询模式融合为一个。
* MR：模式𝑄1和𝑄2及查询结果𝑅1和𝑅2，通过逻辑𝑎𝑛𝑑或𝑜𝑟操作融合得到模式𝑄3及查询结果𝑅3。应有 𝑅3为𝑅1和𝑅2的交集或并集。
* 解释：融合模式的查询结果应与将相同逻辑关系应用于原始模式查询结果后得到的结果一致。
* 样例：𝑄1查询节点𝐴的配偶节点作为𝑅1，𝑄2查询其3跳邻居节点作为𝑅2。通过应用𝑎𝑛𝑑融合，我们得到𝑄3，查询既是节点𝐴的配偶节点又是其3跳邻居节点的节点作为𝑅3。此时，𝑅1与𝑅2的交集应等于𝑅3。
* 注意点
	* 将融合限制在查询相同类型图数据的模式上，因为逻辑操作应应用于相同类型的查询结果。
	* 模式融合变换可以应用于两个以上的查询模式，以构建更复杂的查询和元规则。

**2 Pattern Partitioning(模式划分技术)**
* 定义
	* 将一个复杂模式划分为多个更简单的子模式（扩展文献[34, 42]中的查询划分技术）
* MR：将一个复杂查询模式Q划分为三个子查询模式 Q1、Q2 和 Q3，其谓词分别被评估为 TRUE、FALSE 和 IS NULL。对于这三个子查询，生成三个谓词：p、NOT p、p IS NULL，每个谓词用于在过滤子句中划分原始模式结果集，从而形成一个新的复合蜕变关系，即 Q 的查询结果 R 是三个子模式查询结果的并集（R = R1 ∪ R2 ∪ R3）。
* 样例：在图3(b)中，p用于匹配橙色节点，NOT p用于匹配非橙色节点（即紫色节点），而p IS NULL返回空集。这三个结果集构成了模式一的完整集合。
* 注意点
	* 具体来说，我们的技术扩展了之前的工作[34]。
	* 我们生成了更全面的查询模式，例如支持复杂路径检索和新语法等查询。

### 4.3 Dynamic MRs

* 之前的基础和复合元规则仅覆盖了图数据库中用于搜索和检索静态数据的功能。现实世界中的图数据库工作负载通常涉及频繁的数据更新，包括图数据的添加、删除和修改。
* 考虑到图形数据库中图形数据的动态更新，本文设计了四种图数据变异（graph data mutation）技术和相应的动态图感知MR。
* 主要思想：数据变异会导致相同查询的查询结果发生预期变化或保持不变。通过在特定图数据变异前后提交查询，够判断新查询结果是否正确，从而检测逻辑错误。
* 注意：不需要更改查询模式，可以重用基础或复合元规则中生成的查询模式。

**1 数据添加（Data Addition）**
* 定义：向图中插入新的数据（如节点、边或属性）来突变图形数据。
* MRs：引发多个MRs，其中新查询结果会相应更新。
* 示例MRs
	* 插入与给定查询模式匹配的数据->添加的数据作为新查询结果的一部分被返回
	* 在两个未连接的现有节点之间插入新边，或在其他中间节点之间插入新边->添加后可以找到两个节点之间的路径
	* 两个已连接的节点𝐴和𝐵，以及另一个与它们隔离的节点𝐶，在𝐵和𝐶之间连接一条边->从𝐴到𝐶的任何路径都将包含从𝐴到𝐵的路径作为前缀。


**2 数据删除（Data Deletion)**
* 定义：从图中删除现有数据（如节点、边或属性）实现变异。
* MRs：引发多个MRs，其中新查询结果会相应更新。
* 示例MRs
	* 删除与给定查询模式匹配的数据->新查询结果不包括删除的数据
	* 删除两个连接节点之间直接或间接的所有边->两个节点之间不再存在路径
	* 删除两个连接节点之间路径上的一些边或节点->它们之间返回的路径数量减少。

**3 数据更新(Data Update)**
* 定义：更新图中现有数据（即节点或边的属性）实现变异。
* MRs：引发多个MRs，其中新查询结果会相应更新。
* 示例MRs
	* 更新符合查询条件的节点属性值为其他不符合的值->使数据更新后返回结果的数量减少。
	* 更新其他节点或边的属性为返回结果中的属性值，以符合查询条件->使新查询结果的数量增加。

**4 无关数据操作（Irrelevant Data Manipulation）**
* 定义：对与查询模式无关的数据进行添加、删除或更新。
* MRs：查询结果保持不变
* 示例MRs
	* 给定一个查询模式，添加、删除或更新一些冗余且无关的节点或边，但这些数据不会作为查询结果的一部分返回。


## IMPLEMENTATION

10. Gamera 支持的语言： Cypher 和 Gremlin （这两种主流图形查询语言）。
11. Gamera 工作量：为每种查询语言实现了约 7,000 行代码（LoC），共 14,000 行代码。（其中，图感知蜕变关系的实现大约占用了每种语言 4,000 行代码）
12. Gamera 通用性：只需工程实现工作即可自然移植到其他图形查询语言，如 GSQL 和 AQL（需一定的工程努力）。
13. 生成 Cypher 和 Gremlin 查询
* Cypher：参考了 GDsmith [32] 并使用其基于骨架的和完成技术。
* Gremlin：使用 Grand [47] 的抽象 Gremlin 遍历模型构造有效查询。
* 将提出的MRs集成到查询生成策略中，并开发预言验证器。

## EVALUATION
### Evaluation Setup
14. 测试GDBs
* Cypher: Neo4j 和 RedisGraph
* Gremlin : OrientDB、JanusGraph、HugeGraph、TinkerGraph 和 ArcadeDB
* 选取原则：这些数据库在 DB-Engine Ranking of Graph DBMS 中都名列前茅，其 GitHub 仓库也有大量的星标。这些数据库一般较为复杂，并且在先前的工作中已经经过了充分的测试。

15. 测试方法
* 测试轮次：在每个图形数据库上，针对不同的图感知蜕变关系运行 10 轮测试。
* 图数据库参数及查询数量：每轮测试中，创建一个100 个节点和 200 条边的图数据库，生成 1000 组查询。
* 测试时长：48 小时内。

解说：
* 将 Gamera 配置为在每个图形数据库上针对不同类别的图形感知蜕变关系运行 10 轮测试。每轮测试中，创建一个包含 100 个节点和 200 条边的图形数据库，并生成 1000 组查询来测试图形数据库。
* 特别的：对于动态类中的数据删除蜕变关系，数据删除可能会导致图形数据规模显著减小，容易出现空结果，作者设计了 1000 轮测试，每轮测试都会生成一个新的图形和 10 组查询。
* Gamera 在 48 小时内完成了对所有图形数据库的测试。对于每个报告的错误，手动分析以确认是否为真正的逻辑错误，并过滤掉触发相同问题的重复测试用例。
* 选择100个节点和200条边的规模是基于我们的初步定量研究。具体来说，我们首先评估了Gamera在不同规模的生成图上的表现。结果表明，增加图的规模对漏洞检测能力的影响微乎其微；相反，更大的规模会延长每轮测试的执行时间。因此，我们选择与其他研究[47]相同的测试图规模进行实验。

### Bug Detection
16. 漏洞数量
* Gamera检测到39个漏洞，15个已被确认，3个已被修复。
![[Pasted image 20250204230044.png]]

17. MR的有效性：根据触发漏洞的图感知MR类别对漏洞进行分类。
* 基本MR触发了5个漏洞，包括3个路径检索漏洞和2个节点与边匹配漏洞。（相对较少的漏洞结果是合理的，因为GDB通常在图结构的基本特性方面已经过充分测试。）
* 大多数（39个中的30个）是由复合MR触发的。这30个错误中，25个是通过模式融合变异规则检测到的，5个是通过模式拆分变异规则检测到的。（由于 GDBMeter 已经长期使用查询拆分测试我们数据集中图数据库的旧版本，许多相关的错误已经在最新版本中被发现并修复。因此，Gamera 仅发现五个这样的错误是合理的。）
* 动态MR触发了4个漏洞。

![[Pasted image 20250204231134.png]]



18. 漏洞类型
* 尽管Gamera旨在发现逻辑漏洞，但它也检测到了崩溃和错误。
* 21个逻辑漏洞，9个崩溃漏洞和9个内部漏洞。
* 触发逻辑漏洞的五个主要根本原因。
	* 路径检索功能错误：GDB对路径检索功能的支持存在错误。一些精确路径长度查询或多跳查询未遵循实际的路径长度。
	* 数值计算错误：GDB中的数值计算错误导致结果不准确。这些漏洞是由于在计算非数字（𝑁𝑎𝑁）值、无穷大（𝑖𝑛𝑓𝑖𝑛𝑖𝑡𝑦）和字符串（𝑠𝑡𝑟𝑖𝑛𝑔𝑠）等时得到错误结果引起的。
	* Gremlin API 实现错误：由于Gremlin API（如outside()、gte()和lte()等）的错误实现导致的。
	* 查询模式交集设计缺陷：其他逻辑漏洞是由于在使用𝑢𝑛𝑖𝑜𝑛语法或中间遍历𝐸()等查询模式交集时的设计缺陷引起的。
	* 节点或边的错误计算：还有许多逻辑漏洞是由于节点或边的错误遗漏或冗余计算导致的。

![[Pasted image 20250204233308.png]]

### Comparison with Existing Works

进一步将Gamera与相关的GDB基准测试工具进行了比较。

![[Pasted image 20250204233308.png]]
**1 与 Grand 的比较**
Gamera 在检测错误方面表现更优。
* Grand 在 10000 个查询中报告了 1420 个潜在错误，但经过手动分析，只发现了8个崩溃和内部错误，没有检测到任何逻辑错误。这是因为 Grand 的差异测试预言存在局限性，并且没有考虑有效的图形感知蜕变关系。
* Gamera 成功检测到了所有这些错误，并且没有误报。

**2 与 GDsmith 的比较**
* 发现 Gamera 能够检测到 GDsmith 无法检测到的与图形原生结构相关的逻辑错误，而 GDsmith 不能检测这些错误是因为它不支持图形感知蜕变关系。


**3 与 GDBMeter 的比较**
* GDBMeter 只能检测到 Gamera 能识别的一小部分错误。
* DBMeter 检测到的五个逻辑错误都被 Gamera 成功识别。因为触发其他错误需要支持高级图形查询语言语法和图形感知蜕变关系，而 GDBMeter 不具备这些。


### Case Study

#### K-hop Nodes Relationship Bug in RedisGraph
* 第一个查询查找id为1的节点的所有不同的出站2跳节点，返回的结果集中包含一个id为2的节点。
* 第二个查询查找id为2的节点的所有不同的入站2跳节点。
* id为1的节点应该存在于第二个查询的结果集中。然而测试发现RedisGraph在结果集中遗漏了这个节点，导致了一个逻辑漏洞。
* 开发者确认了这个漏洞并及时修复了它。该漏洞是由于RedisGraph中的多跳遍历未遵循实际路径长度导致的错误。

![[Pasted image 20250205001539.png]]

#### Union Fusion Bug in JanusGraph.

#### RedisGraph Incorrect Result after Graph Data Mutation.

#### Erroneous Value Handling in HugeGraph


## DISCUSSION

**可移植性与可扩展性**
Gamera可以直接应用于使用这些查询语言的其他GDB：Gamera是一种专为使用Cypher和Gremlin的GDB设计的黑盒MT（蜕变测试）方法。我们已经对多个商业GDB（如Neo4j、OrientDB、TinkerGraph）进行了基准测试。

基于图原生结构设计MR的思想具有通用性。它可以用于为使用不同查询语言（如GSQL和AQL等）的GDB实现测试预言机。

**方法的全面性和完整性**
我们相信我们的方法是全面和详尽的，因为我们涵盖了与最常用的图数据库（GDB）操作相关的图感知 MRs，并且我们的复合级 MR 可以逐步从基本的 MRs 生成复杂的 MRs。

由于 GDB 不断有新特性更新以及其他边缘案例，我们承认，由于人力资源的限制，我们无法设计所有的图感知 MRs。尽管如此，我们已经以高度可扩展的方式实现了 Gamera。其他研究人员可以在未来的开源工具基础上，添加新的测试 oracle，结合基本、复合和动态 MRs 的理念。

**局限性**
Gamera 可能会生成重复的漏洞报告，因为它会生成不同的测试用例来触发具有相同根本原因的漏洞，类似于其他黑盒基准测试方法。
目前，我们的分析需要人工努力来简化测试用例并去重报告。

Gamera 目前对与图的原生结构相关的复杂语法的支持不完整。仍然有一些语法是它不支持的，例如图算法操作（如 `pageRank()`）等。


## RELATED WORK

**数据库系统的差异测试（DT）**。DT [38] 是一种常用于检测不同领域系统中漏洞的方法。在关系数据库系统中，一个方向 [31, 45] 是在不同的关系数据库上运行查询并检查结果的不一致性。另一个方向 [33, 46] 是在同一关系数据库的不同设置（如版本或优化级别）下运行查询。RAGS [45] 首次利用DT检测关系数据库系统中的逻辑漏洞。APOLLO [33] 使用DT发现性能回归漏洞。对于图数据库系统，GDsmith [32] 和 Grand [47] 是首次分别使用DT检测基于Cypher和基于Gremlin的GDB漏洞的工作。根据最终在不同GDB中确认的漏洞数量，这两项工作都被证明是有效的漏洞检测工具。然而，正如§2.3中讨论的那样，它们共享DT的一些根本局限性。本文利用蜕变测试（MT）来解决预言机问题，并对每个图数据库进行了更全面的基准测试。

**数据库系统的蜕变测试（MT）**。MT [26] 最初是为了缓解测试预言机缺失问题而提出的。该方法的主要思想是设计蜕变关系（MR）并验证输出。SQLancer [18] 旨在检测关系数据库系统中的逻辑漏洞，它集成了多种新颖的MT方法。NoREC [42] 通过比较给定优化查询与其非优化版本的执行结果，来检测与优化相关的漏洞。TLP [41] 将查询划分为三个子查询，并通过比较三个子查询的组合结果与原始结果来检测逻辑漏洞。GDBMeter [34] 也借鉴了TLP的思想来检测GDB中的逻辑漏洞。然而，上述方法都是为使用SQL类或其他图查询语言的数据库系统设计的，并未考虑图原生结构，因此未能提出一套图感知的MR。我们在§2.3中详细分析了这些技术。


## CONCLUSION

与图的原生结构相关的图数据库（GDB）中的逻辑漏洞尚未得到充分研究。在本研究中，我们提出了 Gamera，一种有效的自动化变形测试方法，用于检测 GDB 中的逻辑漏洞。我们开发了三类新颖的图感知 MR：基本 MR、复合 MR 和动态 MR，以生成高质量的测试，涵盖多样化和复杂的 GDB 操作。我们对七个广泛使用的基于 Cypher 和 Gremlin 的 GDB 进行的评估发现了 39 个漏洞，其中 15 个已得到开发者的确认。Gamera 还显著超越了之前的研究，检测到了它们所能发现的所有漏洞。我们的研究展示了采用图感知 MRs 检测 GDB 中逻辑漏洞的重要性。
